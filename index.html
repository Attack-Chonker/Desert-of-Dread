<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Desert Looks Back</title>
    <style>
        /* --- From style.css --- */
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; }
        canvas { display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
        }
        #warning {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #ccc;
            font-family: monospace;
            font-size: 1.2em;
            pointer-events: none; /* Allows clicks to go through to the game */
        }
        #interaction-prompt {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: monospace;
            font-size: 1.2em;
            pointer-events: none;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="warning">There is nothing out here.</div>
    <div id="interaction-prompt"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/",
                "three/addons/controls/PointerLockControls.js": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/controls/PointerLockControls.js",
                "three/addons/loaders/FontLoader.js": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/FontLoader.js",
                "three/addons/geometries/TextGeometry.js": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/geometries/TextGeometry.js",
                "three/addons/lights/RectAreaLightUniformsLib.js": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/lights/RectAreaLightUniformsLib.js"
            }
        }
    </script>

    <script type="module">
        // --- Combined and processed JavaScript from all files ---

        // --- External Imports (collected from all files) ---
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

        // --- From js/state.js ---
        // --- Global Variables ---
        let audioContext;
        let rumbleNode;
        let neonLights = [];
        let flickeringLights = [];
        let fireMaterial;
        let emberMaterial; // For the new embers
        const interactables = [];
        const doors = [];
        let cat, voidPortal, voidLight, catHead, tentacles = [], moon, catMoon, moonLight, catMoonLight;
        let catState = 'idle'; 
        let catStateTimer = 0;
        const colliders = [];
        const keys = {};
        const movementSpeed = 50;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const clock = new THREE.Clock();
        const cameraDirection = new THREE.Vector3();
        let ghostState = 'hidden', ghostTimer = 0, nextGhostAppearance = 15.0;
        let screenShake = { intensity: 0, duration: 0 };

        function setAudioContext(context) { audioContext = context; }
        function setRumbleNode(node) { rumbleNode = node; }
        function setFireMaterial(material) { fireMaterial = material; }
        function setEmberMaterial(material) { emberMaterial = material; }
        function setCat(newCat) { cat = newCat; }
        function setVoidPortal(newVoidPortal) { voidPortal = newVoidPortal; }
        function setVoidLight(newVoidLight) { voidLight = newVoidLight; }
        function setCatHead(newCatHead) { catHead = newCatHead; }
        function setMoon(newMoon) { moon = newMoon; }
        function setCatMoon(newCatMoon) { catMoon = newCatMoon; }
        function setMoonLight(newMoonLight) { moonLight = newMoonLight; }
        function setCatMoonLight(newCatMoonLight) { catMoonLight = newCatMoonLight; }
        function setCatState(newState) { catState = newState; }
        function setCatStateTimer(newTimer) { catStateTimer = newTimer; }
        function setGhostState(newState) { ghostState = newState; }
        function setGhostTimer(newTimer) { ghostTimer = newTimer; }
        function setNextGhostAppearance(newTime) { nextGhostAppearance = newTime; }
        function setScreenShake(newScreenShake) { screenShake = newScreenShake; }
        function addTentacle(tentacle) { tentacles.push(tentacle); }
        function getTentacles() { return tentacles; }

        // --- From js/Door.js ---
        class Door {
            constructor(isLeft, width, height, material, position) {
                const doorWidthHalf = width / 2;
                
                const doorBody = new THREE.Group();
                
                const panel = new THREE.Mesh(
                    new THREE.BoxGeometry(doorWidthHalf, height, 0.2),
                    material
                );

                const frameThickness = 0.3;
                const frameSide = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, 0.3), material);
                const frameTop = new THREE.Mesh(new THREE.BoxGeometry(doorWidthHalf, frameThickness, 0.3), material);

                const frameLeft = frameSide.clone();
                frameLeft.position.x = -doorWidthHalf / 2 + frameThickness / 2;
                const frameRight = frameSide.clone();
                frameRight.position.x = doorWidthHalf / 2 - frameThickness / 2;
                const frameTopCloned = frameTop.clone();
                frameTopCloned.position.y = height / 2 - frameThickness / 2;
                const frameBottomCloned = frameTop.clone();
                frameBottomCloned.position.y = -height / 2 + frameThickness / 2;
                
                const brace = new THREE.Mesh(new THREE.BoxGeometry(doorWidthHalf * 1.2, frameThickness, 0.3), material);
                const braceTop = brace.clone();
                braceTop.rotation.z = Math.PI / 4 * (isLeft ? 1 : -1);
                const braceBottom = brace.clone();
                braceBottom.rotation.z = Math.PI / 4 * (isLeft ? -1 : 1);
                
                doorBody.add(panel, frameLeft, frameRight, frameTopCloned, frameBottomCloned, braceTop, braceBottom);
                doorBody.position.x = isLeft ? doorWidthHalf / 2 : -doorWidthHalf / 2;
                doorBody.castShadow = true;

                this.doorGroup = new THREE.Group();
                this.doorGroup.add(doorBody);
                this.doorGroup.position.copy(position);
                
                this.doorMesh = doorBody;
                
                this.isAnimating = false;
                this.targetRotation = 0;
                
                this.interactable = {
                    mesh: this.doorGroup,
                    prompt: 'Press E to open',
                    onInteract: () => {
                        if (this.isAnimating) return;
                        const isOpen = this.doorGroup.rotation.y !== 0;
                        this.targetRotation = isOpen ? 0 : Math.PI / 1.8 * (isLeft ? 1 : -1);
                        this.isAnimating = true;
                        this.interactable.prompt = isOpen ? 'Press E to open' : 'Press E to close';
                    }
                };

                interactables.push(this.interactable);
                colliders.push(this.doorMesh);
            }

            addToScene(parent) {
                parent.add(this.doorGroup);
            }

            update(delta) {
                if (this.isAnimating) {
                    this.doorGroup.rotation.y = THREE.MathUtils.lerp(this.doorGroup.rotation.y, this.targetRotation, delta * 8);

                    if (Math.abs(this.doorGroup.rotation.y - this.targetRotation) < 0.01) {
                        this.doorGroup.rotation.y = this.targetRotation;
                        this.isAnimating = false;
                    }
                }
                this.doorMesh.updateWorldMatrix(true, false);
            }
        }

        // --- From js/audio.js ---
        function playMeow() {
            if (!audioContext) return;
            const meowOscillator = audioContext.createOscillator();
            const meowGain = audioContext.createGain();
            meowOscillator.connect(meowGain);
            meowGain.connect(audioContext.destination);
            
            meowOscillator.type = 'sine';
            const now = audioContext.currentTime;
            meowOscillator.frequency.setValueAtTime(800, now);
            meowOscillator.frequency.exponentialRampToValueAtTime(400, now + 0.2);
            
            meowGain.gain.setValueAtTime(0.2, now);
            meowGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
            
            meowOscillator.start(now);
            meowOscillator.stop(now + 0.2);
        }

        function initAudio() {
            if (!audioContext) {
                try {
                    const newAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    setAudioContext(newAudioContext);

                    const bufferSize = 2 * audioContext.sampleRate;
                    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                    const whiteNoise = audioContext.createBufferSource();
                    whiteNoise.buffer = noiseBuffer;
                    whiteNoise.loop = true;
                    whiteNoise.start(0);
                    const windFilter = audioContext.createBiquadFilter();
                    windFilter.type = 'bandpass';
                    windFilter.frequency.setValueAtTime(700, audioContext.currentTime); 
                    windFilter.Q.setValueAtTime(0.8, audioContext.currentTime);
                    const gustLFO = audioContext.createOscillator();
                    gustLFO.type = 'sine';
                    gustLFO.frequency.setValueAtTime(0.2, audioContext.currentTime); 
                    const gustLFOGain = audioContext.createGain();
                    gustLFOGain.gain.setValueAtTime(80, audioContext.currentTime);
                    gustLFO.connect(gustLFOGain);
                    gustLFOGain.connect(windFilter.frequency);
                    gustLFO.start(0);
                    const masterGain = audioContext.createGain();
                    const volumeLFO = audioContext.createOscillator();
                    volumeLFO.type = 'sine';
                    volumeLFO.frequency.setValueAtTime(1 / 22, audioContext.currentTime); 
                    const volumeLFOGain = audioContext.createGain();
                    const maxVolume = 0.008;
                    volumeLFOGain.gain.setValueAtTime(maxVolume / 2, audioContext.currentTime); 
                    volumeLFO.connect(volumeLFOGain);
                    masterGain.gain.setValueAtTime(maxVolume / 2, audioContext.currentTime);
                    volumeLFOGain.connect(masterGain.gain);
                    volumeLFO.start(0);
                    whiteNoise.connect(windFilter);
                    windFilter.connect(masterGain);
                    masterGain.connect(audioContext.destination);
                    const newRumbleOscillator = audioContext.createOscillator();
                    const newRumbleGain = audioContext.createGain();
                    newRumbleOscillator.connect(newRumbleGain);
                    newRumbleGain.connect(audioContext.destination);
                    newRumbleOscillator.type = 'sawtooth';
                    newRumbleOscillator.frequency.setValueAtTime(40, audioContext.currentTime);
                    newRumbleGain.gain.setValueAtTime(0, audioContext.currentTime);
                    newRumbleOscillator.start();
                    setRumbleNode(newRumbleGain);
                } catch (e) { console.error("Web Audio API is not supported", e); }
            }
            if (audioContext && audioContext.state === 'suspended') { audioContext.resume(); }
        }

        // --- From js/scene.js ---
        function setupScene() {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(-150, 4, -460); // Moved across the road

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            RectAreaLightUniformsLib.init();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            return { scene, camera, renderer };
        }

        // --- Helper functions for procedural textures ---
        function createBrickTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const brickWidth = 64;
            const brickHeight = 32;
            const mortar = 4;

            ctx.fillStyle = '#3a2d27'; // Darker Mortar color
            ctx.fillRect(0, 0, 256, 256);

            for (let y = 0; y < 256; y += brickHeight) {
                for (let x = 0; x < 256; x += brickWidth) {
                    const r = 140 + Math.random() * 20;
                    const g = 75 + Math.random() * 15;
                    const b = 63 + Math.random() * 10;
                    ctx.fillStyle = `rgb(${r},${g},${b})`;

                    let offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;
                    ctx.fillRect(x + offsetX, y, brickWidth - mortar, brickHeight - mortar);
                    ctx.fillRect(x + offsetX - brickWidth, y, brickWidth - mortar, brickHeight - mortar);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function createCharredLogTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#1a120b';
            ctx.fillRect(0, 0, 64, 256);

            ctx.strokeStyle = '#ff6000';
            ctx.lineWidth = 2.5;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            for(let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 64, Math.random() * 256);
                ctx.lineTo(Math.random() * 64, Math.random() * 256);
                ctx.stroke();
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createEmberTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(7, 7, 2, 2); // small 2x2 square
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }


        // --- From js/actors.js ---
        function createLightingAndWorld(scene) {
            const ambientLight = new THREE.AmbientLight(0x404050, 0.2);
            scene.add(ambientLight);
            const newMoonLight = new THREE.DirectionalLight(0x8a95a1, 0.6);
            newMoonLight.position.set(100, 200, 100);
            newMoonLight.castShadow = true;
            newMoonLight.shadow.mapSize.width = 2048;
            newMoonLight.shadow.mapSize.height = 2048;
            scene.add(newMoonLight);
            setMoonLight(newMoonLight);

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), new THREE.MeshStandardMaterial({ color: 0x6b5a42 }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const road = new THREE.Mesh(new THREE.PlaneGeometry(500, 15), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
            road.rotation.x = -Math.PI / 2;
            road.position.set(0, 0.01, -470);
            road.receiveShadow = true;
            scene.add(road);
        }

        function createStars(scene) {
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(3000);
                const y = THREE.MathUtils.randFloatSpread(3000);
                const z = THREE.MathUtils.randFloatSpread(3000);
                starVertices.push(x, y, z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function createMoon(scene) {
            const moonSize = 50;
            const moonGeometry = new THREE.SphereGeometry(moonSize, 64, 64);
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;
            context.fillStyle = '#f0f0e8';
            context.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 30 + 5;
                const gray = Math.floor(Math.random() * 50 + 150);
                context.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${Math.random() * 0.5 + 0.2})`;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }
            const moonTexture = new THREE.CanvasTexture(canvas);
            const moonMaterial = new THREE.MeshStandardMaterial({
                map: moonTexture,
                emissive: 0xffffff,
                emissiveMap: moonTexture,
                emissiveIntensity: 0.8,
                transparent: true
            });
            const newMoon = new THREE.Mesh(moonGeometry, moonMaterial);
            newMoon.position.set(200, 300, -800);
            newMoon.rotation.y = Math.PI;
            scene.add(newMoon);
            setMoon(newMoon);
        }

        function createGasStation(scene) {
            const station = new THREE.Group();
            station.position.set(150, 0, -500);
            scene.add(station);
            const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x3d2c1a, roughness: 0.8 });
            const darkWoodMaterial = new THREE.MeshStandardMaterial({ color: 0x241a0f, roughness: 0.9 });
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.9, side: THREE.DoubleSide });
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
            const buildingWidth = 50, buildingDepth = 25, buildingHeight = 10, wallThickness = 0.5;
            const floor = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, wallThickness, buildingDepth), floorMaterial);
            floor.position.y = wallThickness / 2;
            floor.receiveShadow = true;
            station.add(floor);
            const ceiling = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, wallThickness, buildingDepth), wallMaterial);
            ceiling.position.y = buildingHeight - (wallThickness / 2);
            ceiling.castShadow = true;
            station.add(ceiling);
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, buildingHeight, wallThickness), wallMaterial);
            backWall.position.z = -buildingDepth / 2;
            backWall.position.y = buildingHeight / 2;
            station.add(backWall);
            colliders.push(backWall);
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, buildingHeight, buildingDepth), wallMaterial);
            rightWall.position.x = buildingWidth / 2;
            rightWall.position.y = buildingHeight / 2;
            station.add(rightWall);
            colliders.push(rightWall);
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, buildingHeight, buildingDepth), wallMaterial);
            leftWall.position.x = -buildingWidth / 2;
            leftWall.position.y = buildingHeight / 2;
            station.add(leftWall);
            colliders.push(leftWall);
            const doorWidth = 8, doorHeight = 7;
            const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth/2 - doorWidth/2, buildingHeight, wallThickness), wallMaterial);
            frontWallLeft.position.set(-(buildingWidth/4 + doorWidth/4), buildingHeight/2, buildingDepth / 2);
            station.add(frontWallLeft);
            colliders.push(frontWallLeft);
            const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth/2 - doorWidth/2, buildingHeight, wallThickness), wallMaterial);
            frontWallRight.position.set(buildingWidth/4 + doorWidth/4, buildingHeight/2, buildingDepth / 2);
            station.add(frontWallRight);
            colliders.push(frontWallRight);
            const frontWallTop = new THREE.Mesh(new THREE.BoxGeometry(doorWidth, buildingHeight - doorHeight, wallThickness), wallMaterial);
            frontWallTop.position.set(0, doorHeight + (buildingHeight - doorHeight)/2, buildingDepth / 2);
            station.add(frontWallTop);
            colliders.push(frontWallTop);
            const facade = new THREE.Group();
            station.add(facade);
            const facadeSteps = [ { w: 40, h: 4, x: 0 }, { w: 35, h: 3, x: 0 }, { w: 25, h: 2, x: 0 } ];
            let currentHeight = buildingHeight;
            facadeSteps.forEach(step => {
                const facadeBlock = new THREE.Mesh(new THREE.BoxGeometry(step.w, step.h, 1), wallMaterial);
                facadeBlock.position.set(step.x, currentHeight + step.h / 2, buildingDepth / 2 + 0.5);
                facadeBlock.castShadow = true;
                facade.add(facadeBlock);
                currentHeight += step.h;
            });
            const porchDepth = 8;
            const porchFloor = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, 0.5, porchDepth), woodMaterial);
            porchFloor.position.set(0, 0.25, buildingDepth / 2 + porchDepth / 2);
            porchFloor.receiveShadow = true;
            station.add(porchFloor);
            const porchRoof = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, 0.5, porchDepth), darkWoodMaterial);
            porchRoof.position.set(0, buildingHeight + 0.25, buildingDepth / 2 + porchDepth / 2);
            porchRoof.castShadow = true;
            station.add(porchRoof);
            for (let i = -2; i <= 2; i++) {
                if (i === 0) continue;
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, buildingHeight, 8), darkWoodMaterial);
                post.position.set(i * (buildingWidth / 4), buildingHeight / 2, buildingDepth / 2 + porchDepth - 1);
                post.castShadow = true;
                station.add(post);
                colliders.push(post);
            }
            const counter = new THREE.Mesh(new THREE.BoxGeometry(20, 3.5, 3), darkWoodMaterial);
            counter.position.set(0, 3.5/2, -buildingDepth/2 + 5);
            counter.castShadow = true;
            station.add(counter);
            colliders.push(counter);
            for(let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 2), darkWoodMaterial);
                shelf.position.set(-buildingWidth/2 + 8, 4, -buildingDepth/2 + 10 + i * 5);
                shelf.castShadow = true;
                station.add(shelf);
                colliders.push(shelf);
            }
            function createChessboard() {
                const boardGroup = new THREE.Group();
                const tileSize = 0.8;
                const boardSize = 8 * tileSize;
                const darkSquareMaterial = new THREE.MeshStandardMaterial({ color: 0x402218 });
                const lightSquareMaterial = new THREE.MeshStandardMaterial({ color: 0xE8DAB2 });
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const isLight = (i + j) % 2 !== 0;
                        const tileMaterial = isLight ? lightSquareMaterial : darkSquareMaterial;
                        const tile = new THREE.Mesh(new THREE.PlaneGeometry(tileSize, tileSize), tileMaterial);
                        tile.position.set(i * tileSize - boardSize / 2 + tileSize / 2, j * tileSize - boardSize / 2 + tileSize / 2, 0);
                        boardGroup.add(tile);
                    }
                }
                boardGroup.position.set(0, buildingHeight - 0.3, 0);
                boardGroup.rotation.x = Math.PI / 2;
                station.add(boardGroup);
            }
            createChessboard();
            const neonMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const neonRadius = 0.1;
            const outlinePoints = [
                new THREE.Vector3(-buildingWidth/2, buildingHeight, buildingDepth/2 + 1), new THREE.Vector3(buildingWidth/2, buildingHeight, buildingDepth/2 + 1),
                new THREE.Vector3(buildingWidth/2, buildingHeight, buildingDepth/2 + 1), new THREE.Vector3(buildingWidth/2, buildingHeight + facadeSteps[0].h, buildingDepth/2 + 1),
                new THREE.Vector3(20, 14, 13.5), new THREE.Vector3(17.5, 14, 13.5),
                new THREE.Vector3(17.5, 14, 13.5), new THREE.Vector3(17.5, 17, 13.5),
                new THREE.Vector3(17.5, 17, 13.5), new THREE.Vector3(12.5, 17, 13.5),
                new THREE.Vector3(12.5, 17, 13.5), new THREE.Vector3(12.5, 19, 13.5),
                new THREE.Vector3(12.5, 19, 13.5), new THREE.Vector3(-12.5, 19, 13.5),
                new THREE.Vector3(-12.5, 19, 13.5), new THREE.Vector3(-12.5, 17, 13.5),
                new THREE.Vector3(-12.5, 17, 13.5), new THREE.Vector3(-17.5, 17, 13.5),
                new THREE.Vector3(-17.5, 17, 13.5), new THREE.Vector3(-17.5, 14, 13.5),
                new THREE.Vector3(-17.5, 14, 13.5), new THREE.Vector3(-20, 14, 13.5),
                new THREE.Vector3(-buildingWidth/2, buildingHeight + facadeSteps[0].h, buildingDepth/2 + 1), new THREE.Vector3(-buildingWidth/2, buildingHeight, buildingDepth/2 + 1),
            ];
            for (let i = 0; i < outlinePoints.length; i += 2) {
                const start = outlinePoints[i];
                const end = outlinePoints[i+1];
                const path = new THREE.LineCurve3(start, end);
                const tube = new THREE.Mesh(new THREE.TubeGeometry(path, 1, neonRadius, 8, false), neonMaterial);
                station.add(tube);
                const newNeonLight = new THREE.PointLight(0xff0000, 150, 50, 2);
                newNeonLight.position.copy(start.clone().lerp(end, 0.5));
                station.add(newNeonLight);
                neonLights.push(newNeonLight);
            }
        }

        function createZigZagFloorTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 64;
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 128, 64);
            ctx.fillStyle = '#FFFFFF';
            for (let x = 0; x < 128; x += 32) {
                ctx.beginPath();
                ctx.moveTo(x, 0); ctx.lineTo(x + 16, 32); ctx.lineTo(x + 32, 0);
                ctx.closePath(); ctx.fill();
            }
            for (let x = -16; x < 128; x += 32) {
                ctx.beginPath();
                ctx.moveTo(x, 64); ctx.lineTo(x + 16, 32); ctx.lineTo(x + 32, 64);
                ctx.closePath(); ctx.fill();
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(16, 16);
            return texture;
        }

        function createCurtainTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 1;
            const gradient = ctx.createLinearGradient(0, 0, 128, 0);
            gradient.addColorStop(0, '#2c0001');
            gradient.addColorStop(0.2, '#5c0002');
            gradient.addColorStop(0.35, '#8b0003');
            gradient.addColorStop(0.5, '#5c0002');
            gradient.addColorStop(0.7, '#2c0001');
            gradient.addColorStop(0.85, '#5c0002');
            gradient.addColorStop(1, '#4c0001');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 1);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 20);
            return texture;
        }

        function createSaloon(scene) {
            const saloon = new THREE.Group();
            saloon.position.set(-150, 0, -500);
            scene.add(saloon);

            const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x3d2c1a, roughness: 0.8 });
            const darkWoodMaterial = new THREE.MeshStandardMaterial({ color: 0x241a0f, roughness: 0.9 });
            const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.9 });
            const curtainTexture = createCurtainTexture();
            const curtainMaterial = new THREE.MeshStandardMaterial({ map: curtainTexture, roughness: 0.7 });
            const zigZagFloorMaterial = new THREE.MeshStandardMaterial({ map: createZigZagFloorTexture() });
            const exteriorMaterial = darkWoodMaterial;
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x9a7142, roughness: 0.8 });

            const buildingWidth = 40, buildingDepth = 30, buildingHeight = 12, wallThickness = 0.5;

            const floor = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, wallThickness, buildingDepth), zigZagFloorMaterial);
            floor.position.y = wallThickness / 2;
            floor.receiveShadow = true;
            saloon.add(floor);

            const ceiling = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, wallThickness, buildingDepth), darkWoodMaterial);
            ceiling.position.y = buildingHeight - (wallThickness / 2);
            ceiling.castShadow = true;
            saloon.add(ceiling);

            const overheadLight = new THREE.PointLight(0xfff0e1, 0.7, 60, 1.5);
            overheadLight.position.set(0, buildingHeight - 2, 0);
            saloon.add(overheadLight);

            function createWall(width, height, position, rotationY = 0) {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(width, height, wallThickness), exteriorMaterial);
                wall.position.copy(position);
                wall.rotation.y = rotationY;
                saloon.add(wall);
                colliders.push(wall);
            }
            
            createWall(buildingWidth, buildingHeight, new THREE.Vector3(0, buildingHeight / 2, -buildingDepth / 2));
            const backCurtain = new THREE.Mesh(new THREE.PlaneGeometry(buildingWidth, buildingHeight), curtainMaterial);
            backCurtain.position.set(0, buildingHeight / 2, -buildingDepth / 2 + wallThickness);
            saloon.add(backCurtain);
            
            createWall(buildingDepth, buildingHeight, new THREE.Vector3(-buildingWidth / 2, buildingHeight / 2, 0), Math.PI / 2);
            const leftCurtain = new THREE.Mesh(new THREE.PlaneGeometry(buildingDepth, buildingHeight), curtainMaterial);
            leftCurtain.position.set(-buildingWidth / 2 + wallThickness, buildingHeight / 2, 0);
            leftCurtain.rotation.y = Math.PI / 2;
            saloon.add(leftCurtain);

            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, buildingHeight, buildingDepth), stoneMaterial);
            rightWall.position.x = buildingWidth / 2;
            rightWall.position.y = buildingHeight / 2;
            saloon.add(rightWall);
            colliders.push(rightWall);
            
            const doorWidth = 8, doorHeight = 7;
            const frontWallSideWidth = (buildingWidth / 2) - (doorWidth / 2);
            createWall(frontWallSideWidth, buildingHeight, new THREE.Vector3(-(doorWidth + frontWallSideWidth) / 2, buildingHeight / 2, buildingDepth / 2));
            createWall(frontWallSideWidth, buildingHeight, new THREE.Vector3((doorWidth + frontWallSideWidth) / 2, buildingHeight / 2, buildingDepth / 2));
            createWall(doorWidth, buildingHeight - doorHeight, new THREE.Vector3(0, doorHeight + (buildingHeight - doorHeight) / 2, buildingDepth / 2));
            
            const frontCurtainLeft = new THREE.Mesh(new THREE.PlaneGeometry(frontWallSideWidth, buildingHeight), curtainMaterial);
            frontCurtainLeft.position.set(-(doorWidth + frontWallSideWidth) / 2, buildingHeight / 2, buildingDepth / 2 - wallThickness);
            frontCurtainLeft.rotation.y = Math.PI;
            saloon.add(frontCurtainLeft);

            const frontCurtainRight = new THREE.Mesh(new THREE.PlaneGeometry(frontWallSideWidth, buildingHeight), curtainMaterial);
            frontCurtainRight.position.set((doorWidth + frontWallSideWidth) / 2, buildingHeight / 2, buildingDepth / 2 - wallThickness);
            frontCurtainRight.rotation.y = Math.PI;
            saloon.add(frontCurtainRight);

            const frontCurtainTop = new THREE.Mesh(new THREE.PlaneGeometry(doorWidth, buildingHeight - doorHeight), curtainMaterial);
            frontCurtainTop.position.set(0, doorHeight + (buildingHeight - doorHeight) / 2, buildingDepth / 2 - wallThickness);
            frontCurtainTop.rotation.y = Math.PI;
            saloon.add(frontCurtainTop);

            const doorPositionLeft = new THREE.Vector3(-doorWidth / 2, doorHeight / 2, buildingDepth / 2);
            const doorPositionRight = new THREE.Vector3(doorWidth / 2, doorHeight / 2, buildingDepth / 2);

            const leftDoor = new Door(true, doorWidth, doorHeight, doorMaterial, doorPositionLeft);
            leftDoor.addToScene(saloon);
            doors.push(leftDoor);

            const rightDoor = new Door(false, doorWidth, doorHeight, doorMaterial, doorPositionRight);
            rightDoor.addToScene(saloon);
            doors.push(rightDoor);

            const barHeight = 4, barDepth = 3, barWidth = buildingWidth - 10;
            const bar = new THREE.Mesh(new THREE.BoxGeometry(barWidth, barHeight, barDepth), darkWoodMaterial);
            bar.position.set(0, barHeight / 2, -buildingDepth / 2 + barDepth / 2 + 5);
            bar.castShadow = true;
            saloon.add(bar);
            colliders.push(bar);

            const shelfMaterial = darkWoodMaterial;
            const shelfWidth = buildingWidth - 4;
            const shelfHeight = 0.3;
            const shelfDepth = 1.5;

            function createShelf(y) {
                const shelf = new THREE.Mesh(
                    new THREE.BoxGeometry(shelfWidth, shelfHeight, shelfDepth),
                    shelfMaterial
                );
                shelf.position.set(0, y, -buildingDepth / 2 + shelfDepth / 2);
                shelf.castShadow = true;
                saloon.add(shelf);
                return shelf;
            }

            function createBottle() {
                const bottleArchetypes = [
                    { points: [ new THREE.Vector2(0, 0), new THREE.Vector2(0.25, 0), new THREE.Vector2(0.28, 0.4), new THREE.Vector2(0.1, 0.9), new THREE.Vector2(0.12, 1.2), new THREE.Vector2(0.05, 1.3), new THREE.Vector2(0, 1.3) ], scale: 1.05 },
                    { points: [ new THREE.Vector2(0, 0), new THREE.Vector2(0.3, 0), new THREE.Vector2(0.3, 0.6), new THREE.Vector2(0.28, 0.8), new THREE.Vector2(0.1, 1.0), new THREE.Vector2(0, 1.0) ], scale: 1.0 },
                    { points: [ new THREE.Vector2(0, 0), new THREE.Vector2(0.15, 0), new THREE.Vector2(0.15, 1.0), new THREE.Vector2(0.08, 1.3), new THREE.Vector2(0.1, 1.4), new THREE.Vector2(0, 1.4) ], scale: 1.1 },
                    { points: [ new THREE.Vector2(0, 0), new THREE.Vector2(0.1, 0), new THREE.Vector2(0.35, 0.2), new THREE.Vector2(0.3, 0.5), new THREE.Vector2(0.1, 0.8), new THREE.Vector2(0, 0.8) ], scale: 0.95 }
                ];

                const archetype = bottleArchetypes[Math.floor(Math.random() * bottleArchetypes.length)];
                const geometry = new THREE.LatheGeometry(archetype.points, 12);
                
                const bottleMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(Math.random() * 0.5 + 0.2, Math.random() * 0.3 + 0.1, Math.random() * 0.1),
                    transparent: true, opacity: 0.8, roughness: 0.1, metalness: 0.2
                });

                const bottle = new THREE.Mesh(geometry, bottleMaterial);
                bottle.scale.set(1, archetype.scale, 1);
                bottle.castShadow = true;
                
                const topperMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3d2c1a, roughness: 0.9, metalness: 0.1
                });

                const topPoint = archetype.points[archetype.points.length - 2];
                const topRadius = topPoint.x;
                const bottleTopY = topPoint.y * archetype.scale;
                const topperHeight = 0.1;

                const topperGeometry = new THREE.CylinderGeometry(topRadius, topRadius, topperHeight, 8);
                const topper = new THREE.Mesh(topperGeometry, topperMaterial);
                topper.castShadow = true;
                topper.position.y = bottleTopY + (topperHeight / 2);

                const bottleGroup = new THREE.Group();
                bottleGroup.add(bottle);
                bottleGroup.add(topper);
                bottleGroup.userData.geometry = geometry; 
                return bottleGroup;
            }

            const shelfPositionsY = [5, 8.5];
            shelfPositionsY.forEach(y => {
                const shelf = createShelf(y);
                let currentX = -shelfWidth / 2 + 0.5;
                while (currentX < shelfWidth / 2 - 0.5) {
                    const bottleGroup = createBottle();
                    
                    bottleGroup.userData.geometry.computeBoundingBox();
                    const bottleWidth = bottleGroup.userData.geometry.boundingBox.max.x - bottleGroup.userData.geometry.boundingBox.min.x;
                    
                    bottleGroup.position.set(
                        currentX + bottleWidth / 2,
                        y + shelfHeight / 2,
                        shelf.position.z + (Math.random() - 0.5) * shelfDepth * 0.5
                    );
                    saloon.add(bottleGroup);

                    currentX += bottleWidth + (Math.random() * 0.05 + 0.02);
                }
                const shelfLight = new THREE.RectAreaLight(0xffd580, 2, shelfWidth - 1, 0.2);
                shelfLight.position.set(0, y - 0.2, shelf.position.z);
                shelfLight.lookAt(0, y - 1, shelf.position.z);
                saloon.add(shelfLight);
            });

            // --- MORE DETAILED FIREPLACE (FIXED) ---
            const fireplaceAssembly = new THREE.Group();
            saloon.add(fireplaceAssembly);

            const chimneyWidth = 8, chimneyDepth = 4, openingHeight = 5, openingWidth = 5;
            const assemblyX = buildingWidth / 2 - chimneyDepth / 2;
            fireplaceAssembly.position.set(assemblyX, 0, 0);
            fireplaceAssembly.rotation.y = -Math.PI / 2;
            
            const brickTexture = createBrickTexture();
            const fireplaceMaterial = new THREE.MeshStandardMaterial({ map: brickTexture });

            // Create the chimney from multiple parts to form an opening
            const sideWidth = (chimneyWidth - openingWidth) / 2;

            // Left side part
            const leftChimneyPart = new THREE.Mesh(
                new THREE.BoxGeometry(sideWidth, openingHeight, chimneyDepth),
                stoneMaterial
            );
            leftChimneyPart.position.set(-(openingWidth / 2 + sideWidth / 2), openingHeight / 2, 0);
            fireplaceAssembly.add(leftChimneyPart);
            colliders.push(leftChimneyPart);

            // Right side part
            const rightChimneyPart = new THREE.Mesh(
                new THREE.BoxGeometry(sideWidth, openingHeight, chimneyDepth),
                stoneMaterial
            );
            rightChimneyPart.position.set(openingWidth / 2 + sideWidth / 2, openingHeight / 2, 0);
            fireplaceAssembly.add(rightChimneyPart);
            colliders.push(rightChimneyPart);
            
            // Top part (lintel and above)
            const topChimneyPart = new THREE.Mesh(
                new THREE.BoxGeometry(chimneyWidth, buildingHeight + 5 - openingHeight, chimneyDepth),
                stoneMaterial
            );
            topChimneyPart.position.set(0, openingHeight + (buildingHeight + 5 - openingHeight) / 2, 0);
            fireplaceAssembly.add(topChimneyPart);
            colliders.push(topChimneyPart);


            const backBrick = new THREE.Mesh(new THREE.PlaneGeometry(openingWidth, openingHeight), fireplaceMaterial);
            backBrick.position.set(0, openingHeight/2, -chimneyDepth/2 + 0.01);
            fireplaceAssembly.add(backBrick);

            const sideBrickGeo = new THREE.PlaneGeometry(chimneyDepth, openingHeight);
            sideBrickGeo.rotateY(Math.PI/2);
            const leftSideBrick = new THREE.Mesh(sideBrickGeo, fireplaceMaterial);
            leftSideBrick.position.set(-openingWidth/2, openingHeight/2, 0);
            fireplaceAssembly.add(leftSideBrick);
            const rightSideBrick = new THREE.Mesh(sideBrickGeo, fireplaceMaterial);
            rightSideBrick.position.set(openingWidth/2, openingHeight/2, 0);
            fireplaceAssembly.add(rightSideBrick);

            const hearth = new THREE.Mesh(
                new THREE.BoxGeometry(chimneyWidth + 2, 0.5, chimneyDepth + 2),
                stoneMaterial
            );
            hearth.position.y = 0.25;
            fireplaceAssembly.add(hearth);
            colliders.push(hearth);

            const mantle = new THREE.Mesh(
                new THREE.BoxGeometry(chimneyWidth + 1, 0.8, chimneyDepth - 1),
                darkWoodMaterial
            );
            mantle.position.y = openingHeight + 0.4;
            mantle.castShadow = true;
            fireplaceAssembly.add(mantle);

            // -- Fire Grate --
            const grateMaterial = new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.4});
            const grate = new THREE.Group();
            grate.position.set(0, 0.5, 1);
            fireplaceAssembly.add(grate);
            const barGeo = new THREE.BoxGeometry(0.2, 0.2, chimneyDepth - 1.5);
            for(let i=0; i<5; i++){
                const bar = new THREE.Mesh(barGeo, grateMaterial);
                bar.position.x = (i - 2) * 1.0;
                grate.add(bar);
            }
            const frontBar = new THREE.Mesh(new THREE.BoxGeometry(openingWidth-0.5, 0.2, 0.2), grateMaterial);
            frontBar.position.z = (chimneyDepth - 1.5)/2;
            grate.add(frontBar);


            function createPorchLight(x, isFlickering) {
                const porchLight = new THREE.SpotLight(0xffd580, 20, 30, Math.PI * 0.4, 0.5, 2);
                porchLight.position.set(x, buildingHeight, buildingDepth / 2 + 3);
                porchLight.castShadow = true;
                
                const target = new THREE.Object3D();
                target.position.set(x, 0, buildingDepth / 2);
                saloon.add(target);
                porchLight.target = target;
                
                saloon.add(porchLight);

                if (isFlickering) {
                    flickeringLights.push(porchLight);
                }
            }

            createPorchLight(0, false);
            createPorchLight(-buildingWidth / 2 + 6, true);
            createPorchLight(buildingWidth / 2 - 6, false);
            
            // --- Realistic Fire Effect ---
            const fireHolder = new THREE.Group();
            fireHolder.position.set(0, 0.8, 1);
            fireplaceAssembly.add(fireHolder);

            // -- Flames --
            const particleCount = 400;
            const positions = new Float32Array(particleCount * 3);
            const randoms = new Float32Array(particleCount * 3); 
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * openingWidth * 0.7;
                positions[i * 3 + 1] = Math.random() * 0.5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 1.5;
                
                randoms[i * 3] = Math.random(); 
                randoms[i * 3 + 1] = Math.random() * 0.5 + 0.5;
                randoms[i * 3 + 2] = (Math.random() - 0.5) * 2.0;
            }
            const fireGeometry = new THREE.BufferGeometry();
            fireGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            fireGeometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

            const newFireMat = new THREE.ShaderMaterial({
                uniforms: {
                    u_time: { value: 0.0 },
                    u_pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') }
                },
                vertexShader: `
                    uniform float u_time;
                    attribute vec3 aRandom;
                    varying float vAlpha;

                    void main() {
                        vec3 pos = position;
                        float life = mod(u_time * (0.6 + aRandom.x * 0.2) + aRandom.x * 10.0, 3.5);
                        float progress = life / 3.5;
                        
                        pos.y += progress * progress * 5.0;
                        pos.x += sin(life * 2.5 + aRandom.x * 5.0) * aRandom.z * 1.2 * progress;
                        pos.z += cos(life * 2.0 + aRandom.x * 6.0) * aRandom.z * 1.2 * progress;

                        vAlpha = 1.0 - progress;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = (200.0 / -mvPosition.z) * vAlpha * aRandom.y;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D u_pointTexture;
                    varying float vAlpha;

                    void main() {
                        vec3 color1 = vec3(1.0, 0.9, 0.5);
                        vec3 color2 = vec3(1.0, 0.4, 0.0);
                        vec3 color3 = vec3(0.4, 0.0, 0.0);

                        vec3 flameColor = mix(color2, color1, smoothstep(0.0, 0.4, vAlpha));
                        flameColor = mix(color3, flameColor, smoothstep(0.4, 1.0, vAlpha));

                        float strength = texture2D(u_pointTexture, gl_PointCoord).r;
                        strength *= smoothstep(0.0, 0.1, vAlpha) * smoothstep(1.0, 0.5, vAlpha);

                        if (strength < 0.01) discard;

                        gl_FragColor = vec4(flameColor, strength);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            setFireMaterial(newFireMat);

            const fire = new THREE.Points(fireGeometry, newFireMat);
            fireHolder.add(fire);

            // -- Embers --
            const emberCount = 150;
            const emberPositions = new Float32Array(emberCount * 3);
            const emberRandoms = new Float32Array(emberCount * 3);
            for (let i = 0; i < emberCount; i++) {
                emberPositions[i*3] = (Math.random() - 0.5) * openingWidth * 0.9;
                emberPositions[i*3+1] = (Math.random() - 0.5) * 0.2;
                emberPositions[i*3+2] = (Math.random() - 0.5) * 1.8;
                emberRandoms[i*3] = Math.random();
                emberRandoms[i*3+1] = Math.random();
                emberRandoms[i*3+2] = Math.random() * 0.8 + 0.2; // size
            }
            const emberGeometry = new THREE.BufferGeometry();
            emberGeometry.setAttribute('position', new THREE.BufferAttribute(emberPositions, 3));
            emberGeometry.setAttribute('aRandom', new THREE.BufferAttribute(emberRandoms, 3));

            const newEmberMat = new THREE.ShaderMaterial({
                 uniforms: {
                    u_time: { value: 0.0 },
                    u_pointTexture: { value: createEmberTexture() } // Use new sharp texture
                },
                vertexShader: `
                    uniform float u_time;
                    attribute vec3 aRandom;
                    varying float vIntensity;
                    
                    // Function to get a pseudo-random progress for each particle's life
                    float progress(float time, float randomOffset) {
                        return fract(time * 0.2 + randomOffset);
                    }

                    void main() {
                        vec3 pos = position;
                        float time = u_time * 0.8;
                        float lifeProgress = progress(time, aRandom.x);

                        // Move upwards as life progresses
                        pos.y += sin(time * (1.0 + aRandom.x) + aRandom.y * 10.0) * 0.1 + lifeProgress * 1.5;
                        pos.x += sin(time * 0.5 + aRandom.x * 5.0) * 0.1;
                        
                        // Fade out as it rises
                        vIntensity = 0.5 + sin(time * (1.5 + aRandom.x) + aRandom.y * 5.0) * 0.5;
                        vIntensity *= (1.0 - lifeProgress);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = (50.0 / -mvPosition.z) * aRandom.z * vIntensity;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D u_pointTexture;
                    varying float vIntensity;
                    void main() {
                        vec3 emberColor = vec3(1.0, 0.2, 0.0);
                        // Using the alpha from our simple square texture
                        float strength = texture2D(u_pointTexture, gl_PointCoord).a;
                        if (strength < 0.5) discard;
                        gl_FragColor = vec4(emberColor, strength * vIntensity * 2.0);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            setEmberMaterial(newEmberMat);
            const embers = new THREE.Points(emberGeometry, newEmberMat);
            fireHolder.add(embers);


            // -- Logs --
            const logTexture = createCharredLogTexture();
            const logMaterial = new THREE.MeshStandardMaterial({ 
                map: logTexture,
                emissiveMap: logTexture,
                emissive: 0xffffff,
                emissiveIntensity: 0.8,
                color: 0x1a120b, 
                roughness: 0.9 
            });
            const logGeometry = new THREE.CylinderGeometry(0.3, 0.25, openingWidth * 0.7, 8);
            const log1 = new THREE.Mesh(logGeometry, logMaterial);
            log1.position.set(-0.8, -0.1, 0.2);
            log1.rotation.z = Math.PI / 2;
            log1.rotation.x = Math.PI / 10;
            fireHolder.add(log1);
            const log2 = new THREE.Mesh(logGeometry, logMaterial);
            log2.position.set(0.8, -0.1, -0.2);
            log2.rotation.z = Math.PI / 2;
            log2.rotation.x = -Math.PI / 12;
            fireHolder.add(log2);
            const log3 = new THREE.Mesh(logGeometry, logMaterial);
            log3.position.set(0, 0.2, 0);
            log3.rotation.z = Math.PI / 2;
            fireHolder.add(log3);


            const fireLight = new THREE.PointLight(0xff7700, 2.5, 40, 2);
            fireLight.position.set(0, openingHeight / 2, chimneyDepth / 2 + 1.5);
            fireplaceAssembly.add(fireLight);
            flickeringLights.push(fireLight);

            const porchDepth = 10;
            const porchFloor = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, 0.5, porchDepth), woodMaterial);
            porchFloor.position.set(0, 0.25, buildingDepth / 2 + porchDepth / 2);
            porchFloor.receiveShadow = true;
            saloon.add(porchFloor);

            const porchRoof = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth, 0.5, porchDepth), darkWoodMaterial);
            porchRoof.position.set(0, buildingHeight + 0.25, buildingDepth / 2 + porchDepth / 2);
            porchRoof.castShadow = true;
            saloon.add(porchRoof);

            for (let i = -1; i <= 1; i++) {
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, buildingHeight, 8), darkWoodMaterial);
                post.position.set(i * (buildingWidth / 2.5), buildingHeight / 2, buildingDepth / 2 + porchDepth - 1);
                post.castShadow = true;
                saloon.add(post);
                colliders.push(post);
            }

            const sign = new THREE.Mesh(new THREE.BoxGeometry(12, 5, 0.5), woodMaterial);
            sign.position.set(0, buildingHeight + 5, buildingDepth/2);
            saloon.add(sign);

            const loader = new FontLoader();
            loader.load('https://cdn.jsdelivr.net/npm/three@0.165.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                const textMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 1
                });
                const text = "Tachonker's Tavern";
                const textGeometry = new TextGeometry(text, {
                    font: font,
                    size: 1.5,
                    height: 0.2,
                });
                textGeometry.computeBoundingBox();
                const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(-textWidth / 2, buildingHeight + 4, buildingDepth / 2 + 0.3);
                saloon.add(textMesh);

                let xOffset = 0;
                for (let i = 0; i < text.length; i++) {
                    const letter = text[i];
                    if (letter === ' ') {
                        xOffset += 0.5; 
                        continue;
                    }
                    const letterGeom = new TextGeometry(letter, {
                        font: font,
                        size: 1.5,
                        height: 0.2,
                    });
                    letterGeom.computeBoundingBox();
                    const letterWidth = letterGeom.boundingBox.max.x - letterGeom.boundingBox.min.x;

                    if (['a', 'c', 'o', 'r'].includes(letter.toLowerCase())) {
                        const letterLight = new THREE.PointLight(0xFFD700, 2, 5, 2);
                        letterLight.position.set(-textWidth / 2 + xOffset + letterWidth / 2, buildingHeight + 5, buildingDepth / 2 + 1);
                        saloon.add(letterLight);
                        flickeringLights.push(letterLight);
                    }
                    xOffset += letterWidth;
                }
            });
        }

        function createCat(scene) {
            const newCat = new THREE.Group();
            scene.add(newCat);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });
            const innerEarMaterial = new THREE.MeshStandardMaterial({ color: 0xdb7093, roughness: 0.9 });
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffc940 });
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const bodyMesh = new THREE.Mesh(new THREE.SphereGeometry(1.4, 20, 16), bodyMaterial);
            bodyMesh.scale.set(1, 1.2, 0.9);
            bodyMesh.position.y = (1.4 * 1.2) / 2;
            bodyMesh.castShadow = true;
            newCat.add(bodyMesh);
            const newCatHead = new THREE.Group();
            newCat.add(newCatHead);
            newCatHead.position.y = (1.4 * 1.2) + 0.5;
            newCatHead.position.z = 0.2;
            const headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.8, 20, 16), bodyMaterial);
            headMesh.castShadow = true;
            newCatHead.add(headMesh);
            const eyeRadius = 0.15;
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(eyeRadius, 12, 8), eyeMaterial);
            leftEye.position.set(0.3, 0.15, 0.7);
            leftEye.name = "leftEye";
            newCatHead.add(leftEye);
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(eyeRadius, 12, 8), eyeMaterial);
            rightEye.position.set(-0.3, 0.15, 0.7);
            rightEye.name = "rightEye";
            newCatHead.add(rightEye);
            const pupil = new THREE.Mesh(new THREE.CircleGeometry(eyeRadius * 0.6, 12), pupilMaterial);
            pupil.position.z = 0.7 + eyeRadius + 0.01;
            const leftPupil = pupil.clone();
            leftPupil.position.x = 0.3;
            leftPupil.position.y = 0.15;
            const rightPupil = pupil.clone();
            rightPupil.position.x = -0.3;
            rightPupil.position.y = 0.15;
            newCatHead.add(leftPupil, rightPupil);
            const earScale = 2.8;
            const earOuter = new THREE.Mesh(new THREE.ConeGeometry(0.25 * earScale, 0.5 * earScale, 8), bodyMaterial);
            const earInner = new THREE.Mesh(new THREE.ConeGeometry(0.18 * earScale, 0.4 * earScale, 8), innerEarMaterial);
            earInner.position.z = 0.05;
            const leftEar = new THREE.Group().add(earOuter.clone(), earInner.clone());
            leftEar.position.set(0.4, 0.5, 0);
            leftEar.rotation.set(0, 0, -Math.PI / 10);
            const rightEar = new THREE.Group().add(earOuter.clone(), earInner.clone());
            rightEar.position.set(-0.4, 0.5, 0);
            rightEar.rotation.z = Math.PI / 10;
            newCatHead.add(leftEar, rightEar);
            const leg = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 8), bodyMaterial);
            leg.scale.set(0.8 * 0.7, 1.8 * 0.7, 0.8 * 0.7);
            leg.position.y = 0.6;
            leg.position.z = 1;
            leg.castShadow = true;
            const leftLeg = leg.clone();
            leftLeg.position.x = 0.45;
            const rightLeg = leg.clone();
            rightLeg.position.x = -0.45;
            newCat.add(leftLeg, rightLeg);
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.45, 12, 8), accentMaterial);
            paw.scale.set(1.1 * 0.7, 0.7 * 0.7, 1 * 0.7);
            paw.position.y = 0.2;
            paw.position.z = 1.2;
            paw.castShadow = true;
            const leftPaw = paw.clone();
            leftPaw.position.x = 0.45;
            const rightPaw = paw.clone();
            rightPaw.position.x = -0.45;
            newCat.add(leftPaw, rightPaw);
            const tailCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0.8, -0.6), new THREE.Vector3(-0.8, 0.4, -1.0),
                new THREE.Vector3(-1.5, 0.15, -0.4), new THREE.Vector3(-1.8, 0.1, 0.3),
            ]);
            const tailGeometry = new THREE.TubeGeometry(tailCurve, 32, 0.2, 8, false);
            const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
            tail.castShadow = true;
            newCat.add(tail);
            newCat.position.set(150, 0, -515);
            newCat.rotation.y = Math.PI;

            setCat(newCat);
            setCatHead(newCatHead);
        }

        function createVoidPortalAndTentacles(scene) {
            const portalGeometry = new THREE.CircleGeometry(5, 64);
            const portalMaterial = new THREE.ShaderMaterial({
                uniforms: { u_time: { value: 0.0 }, },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `
                    uniform float u_time; varying vec2 vUv;
                    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); }
                    float noise(vec2 st) {
                        vec2 i = floor(st); vec2 f = fract(st);
                        float a = random(i); float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                    }
                    void main() {
                        vec2 p = vUv - 0.5; float r = length(p); float angle = atan(p.y, p.x);
                        float swirl = noise(vec2(r * 4.0 - u_time * 0.3, angle * 2.0));
                        vec3 color = vec3(swirl * 0.2, 0.0, swirl * 0.4);
                        float edge = 1.0 - smoothstep(0.4, 0.5, r);
                        gl_FragColor = vec4(color, edge);
                    }`,
                transparent: true, side: THREE.DoubleSide
            });
            const newVoidPortal = new THREE.Mesh(portalGeometry, portalMaterial);
            newVoidPortal.position.set(150, 0.1, -515);
            newVoidPortal.rotation.x = -Math.PI / 2;
            newVoidPortal.scale.set(0, 0, 0);
            scene.add(newVoidPortal);
            setVoidPortal(newVoidPortal);

            const newVoidLight = new THREE.PointLight(0x440044, 0, 30, 2);
            newVoidLight.position.set(150, 2, -515);
            scene.add(newVoidLight);
            setVoidLight(newVoidLight);

            const tentacleMaterial = new THREE.MeshStandardMaterial({ color: 0x100010, roughness: 0.8 });
            for (let i = 0; i < 5; i++) {
                const points = [];
                for (let j = 0; j < 10; j++) {
                    points.push(new THREE.Vector3(0, j * 1.5, 0));
                }
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, 20, 0.3, 8, false);
                const tentacle = new THREE.Mesh(geometry, tentacleMaterial);
                const angle = (i / 5) * Math.PI * 2;
                const radius = Math.random() * 2 + 1.5;
                tentacle.position.set(newVoidPortal.position.x + Math.cos(angle) * radius, -10, newVoidPortal.position.z + Math.sin(angle) * radius);
                tentacle.userData.angle = angle;
                tentacle.userData.radius = radius;
                tentacle.visible = false;
                scene.add(tentacle);
                addTentacle(tentacle);
            }
        }

        function createTrashCans(scene) {
            const canMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.5 });
            const createCan = (x, z, rotation) => {
                const canGroup = new THREE.Group(); scene.add(canGroup);
                canGroup.position.set(x, 0, z); canGroup.rotation.y = rotation;
                const body = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.4, 4, 12), canMaterial);
                body.position.y = 2; body.castShadow = true; canGroup.add(body); colliders.push(body);
                const lid = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.3, 12), canMaterial);
                lid.position.y = 4.15; lid.castShadow = true; lid.rotation.x = Math.PI / 16; canGroup.add(lid);
            };
            createCan(147, -515, Math.PI / 8); createCan(153, -515, -Math.PI / 12);
        }

        function createVegetation(scene) {
            const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x2e602e });
            const shrubMaterial = new THREE.MeshStandardMaterial({ color: 0x1a3a1a });
            function createCactus(x, z) {
                const cactus = new THREE.Group();
                const mainHeight = Math.random() * 2.5 + 1;
                const mainBody = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, mainHeight, 8), cactusMaterial);
                mainBody.position.y = mainHeight / 2;
                mainBody.castShadow = true;
                cactus.add(mainBody);
                const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1, 8), cactusMaterial);
                arm.position.set(0.3, mainHeight * 0.7, 0);
                arm.rotation.z = -Math.PI / 2;
                arm.castShadow = true;
                cactus.add(arm);
                cactus.position.set(x, 0, z);
                scene.add(cactus);
            }
            function createShrub(x, z) {
                const shrub = new THREE.Mesh(new THREE.SphereGeometry(Math.random() * 0.8 + 0.4, 8, 6), shrubMaterial);
                shrub.position.set(x, 0.5, z);
                shrub.castShadow = true;
                scene.add(shrub);
            }
            for (let i = 0; i < 200; i++) {
                const x = (Math.random() - 0.5) * 500;
                const z = (Math.random() - 0.5) * 500;
                if (x*x + z*z > 100) {
                    if (Math.random() > 0.5) createCactus(x, z);
                    else createShrub(x, z);
                }
            }
        }

        function createFace(scene) {
            const face = new THREE.Group();
            const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
            const facePlane = new THREE.Mesh(new THREE.PlaneGeometry(8, 11), faceMaterial);
            face.add(facePlane);
            const featureMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2.2), featureMaterial);
            leftEye.position.set(-2, 2, 0.1);
            face.add(leftEye);
            const rightEye = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2.2), featureMaterial);
            rightEye.position.set(2, 2, 0.1);
            face.add(rightEye);
            const mouth = new THREE.Mesh(new THREE.PlaneGeometry(2, 3.5), featureMaterial);
            mouth.position.set(0, -2.5, 0.1);
            face.add(mouth);
            face.visible = false;
            scene.add(face);
            return face;
        }

        // --- From js/controls.js ---
        function setupControls(camera) {
            const controls = new PointerLockControls(camera, document.body);
            document.body.addEventListener('click', () => { 
                controls.lock(); 
                initAudio();
            });
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                if (event.code === 'KeyE') {
                    let closestInteractable = null;
                    let closestDist = 5;
                    interactables.forEach(interactable => {
                        const worldPosition = new THREE.Vector3();
                        interactable.mesh.getWorldPosition(worldPosition);
                        const dist = camera.position.distanceTo(worldPosition);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestInteractable = interactable;
                        }
                    });
                    if (closestInteractable) {
                        closestInteractable.onInteract();
                    }
                }
            });
            document.addEventListener('keyup', (event) => { keys[event.code] = false; });
            return controls;
        }

        function checkCollision(playerNextPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(playerNextPos, new THREE.Vector3(1, 5, 1));
            for (const collider of colliders) {
                const colliderBox = new THREE.Box3().setFromObject(collider);
                if (playerBox.intersectsBox(colliderBox)) {
                    return true;
                }
            }
            return false;
        }

        function updateMovement(delta, controls) {
            velocity.set(0, 0, 0);
            controls.getDirection(direction);
            direction.y = 0;
            direction.normalize();
            const right = new THREE.Vector3(-direction.z, 0, direction.x);
            if (keys['KeyW']) velocity.add(direction);
            if (keys['KeyS']) velocity.sub(direction);
            if (keys['KeyD']) velocity.add(right);
            if (keys['KeyA']) velocity.sub(right);
            if (velocity.length() > 0) {
                velocity.normalize().multiplyScalar(movementSpeed * delta);
                const player = controls.getObject();
                let nextPosX = new THREE.Vector3(player.position.x + velocity.x, player.position.y, player.position.z);
                if (!checkCollision(nextPosX)) {
                    player.position.x += velocity.x;
                }
                let nextPosZ = new THREE.Vector3(player.position.x, player.position.y, player.position.z + velocity.z);
                if (!checkCollision(nextPosZ)) {
                    player.position.z += velocity.z;
                }
            }
        }

        // --- From js/gameLoop.js ---
        function handleInteractions(camera) {
            const prompt = document.getElementById('interaction-prompt');
            let closestInteractable = null;
            let closestDist = 5; 

            interactables.forEach(interactable => {
                const worldPosition = new THREE.Vector3();
                interactable.mesh.getWorldPosition(worldPosition);
                const dist = camera.position.distanceTo(worldPosition);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestInteractable = interactable;
                }
            });

            if (closestInteractable) {
                prompt.innerText = closestInteractable.prompt;
                prompt.style.display = 'block';
            } else {
                prompt.style.display = 'none';
            }
        }

        function updateAnimations(delta) {
            doors.forEach(door => door.update(delta));
        }

        function createGameLoop(scene, camera, renderer, controls, face) {
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                const time = clock.getElapsedTime();

                if (controls.isLocked) {
                    updateMovement(delta, controls);
                }
                
                if (fireMaterial) {
                    fireMaterial.uniforms.u_time.value = time;
                }
                if (emberMaterial) {
                    emberMaterial.uniforms.u_time.value = time;
                }


                const distanceToCat = cat ? camera.position.distanceTo(cat.position) : Infinity;

                switch(catState) {
                    case 'idle':
                        if (catHead) catHead.lookAt(camera.position);
                        if (distanceToCat < 25) {
                            playMeow();
                            setCatState('approaching');
                        }
                        break;
                    case 'approaching':
                        if (catHead) catHead.lookAt(camera.position);
                        if (distanceToCat > 10) {
                            const moveDirection = new THREE.Vector3().subVectors(camera.position, cat.position).normalize();
                            cat.position.x += moveDirection.x * 1.5 * delta;
                            cat.position.z += moveDirection.z * 1.5 * delta;
                            voidPortal.position.x = cat.position.x;
                            voidPortal.position.z = cat.position.z;
                            voidLight.position.x = cat.position.x;
                            voidLight.position.z = cat.position.z;
                            getTentacles().forEach(t => {
                                t.position.x = cat.position.x + Math.cos(t.userData.angle) * t.userData.radius;
                                t.position.z = cat.position.z + Math.sin(t.userData.angle) * t.userData.radius;
                            });
                        } else {
                            setCatState('staring');
                            setCatStateTimer(2.0);
                        }
                        break;
                    case 'staring':
                        if (catHead) catHead.lookAt(camera.position);
                        setCatStateTimer(catStateTimer - delta);
                        if (catStateTimer <= 0) {
                            setCatState('horrifying');
                            setCatStateTimer(3.0);
                            const redEyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 2 });
                            cat.getObjectByName("leftEye").material = redEyeMaterial;
                            cat.getObjectByName("rightEye").material = redEyeMaterial;
                            if (rumbleNode) rumbleNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 1.0);
                            setScreenShake({ duration: 8.0, intensity: 0.05 });
                        }
                        break;
                    case 'horrifying':
                        if (catHead.rotation.y < Math.PI * 2) {
                            catHead.rotation.y += (Math.PI * 2 / 3.0) * delta;
                        }
                        setCatStateTimer(catStateTimer - delta);
                        if (catStateTimer <= 0) {
                            setCatState('descending');
                        }
                        break;
                    case 'descending':
                        if (catHead) catHead.lookAt(camera.position);
                        voidPortal.scale.lerp(new THREE.Vector3(1, 1, 1), 0.05);
                        voidLight.intensity = Math.min(voidLight.intensity + 2 * delta, 5);
                        if (voidPortal.material.uniforms) voidPortal.material.uniforms.u_time.value = time;
                        getTentacles().forEach(t => {
                            t.visible = true;
                            t.position.y = Math.min(t.position.y + 3 * delta, 0);
                            const points = t.geometry.parameters.path.points;
                            for(let i = 0; i < points.length; i++) {
                                const angle = time * 2 + i * 0.5;
                                points[i].x = Math.sin(angle) * 0.5;
                                points[i].z = Math.cos(angle) * 0.5;
                            }
                            t.geometry = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 20, 0.3, 8, false);
                        });
                        if (voidPortal.scale.x > 0.9) {
                            cat.position.y -= 1.0 * delta;
                        }
                        if (cat.position.y < -5) {
                            setCatState('descended');
                        }
                        break;
                    case 'descended':
                        voidPortal.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                        voidLight.intensity = Math.max(voidLight.intensity - 4 * delta, 0);
                        if (rumbleNode) rumbleNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1.0);
                        getTentacles().forEach(t => { t.position.y -= 5 * delta; });
                        if (voidPortal.scale.x < 0.01) {
                            scene.remove(cat);
                            scene.remove(voidPortal);
                            scene.remove(voidLight);
                            getTentacles().forEach(t => scene.remove(t));
                            setCat(null);
                            setCatState('quiet_respite');
                            setCatStateTimer(5.0);
                        }
                        break;
                    case 'quiet_respite':
                        setCatStateTimer(catStateTimer - delta);
                        if (catStateTimer <= 0) {
                            const newCatMoon = catHead.clone();
                            newCatMoon.scale.setScalar(moon.geometry.parameters.radius / 0.8);
                            newCatMoon.position.copy(moon.position);
                            newCatMoon.traverse(child => {
                                if (child.isMesh) {
                                    child.material = child.material.clone();
                                    child.material.transparent = true;
                                    child.material.opacity = 0;
                                }
                            });
                            scene.add(newCatMoon);
                            setCatMoon(newCatMoon);
                            const newCatMoonLight = new THREE.PointLight(0xff0000, 0, 2000, 1);
                            newCatMoonLight.position.copy(moon.position);
                            scene.add(newCatMoonLight);
                            setCatMoonLight(newCatMoonLight);
                            setCatState('moon_swap');
                        }
                        break;
                    case 'moon_swap':
                        if (moon) {
                            moon.material.opacity -= 0.2 * delta;
                            moonLight.intensity -= 0.12 * delta;
                            if (moon.material.opacity <= 0) {
                                scene.remove(moon);
                                setMoon(null);
                            }
                        }
                        if (catMoon) {
                            catMoon.traverse(child => {
                                if (child.isMesh) {
                                    child.material.opacity = Math.min(child.material.opacity + 0.2 * delta, 1);
                                }
                            });
                            catMoonLight.intensity = Math.min(catMoonLight.intensity + 0.4 * delta, 2);
                            if (catMoon.children[0].material.opacity >= 1) {
                                setCatState('watching');
                                document.getElementById('warning').innerText = "IT IS WATCHING";
                            }
                        }
                        break;
                    case 'watching':
                        if (catMoon) catMoon.lookAt(camera.position);
                        break;
                }

                if (screenShake.duration > 0) {
                    camera.position.x += (Math.random() - 0.5) * screenShake.intensity;
                    camera.position.y += (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.duration -= delta;
                } else {
                    screenShake.intensity = 0;
                }

                neonLights.forEach(light => { if (Math.random() > 0.98) { light.intensity = light.intensity > 0 ? 0 : 150; } });
                flickeringLights.forEach(light => {
                    if (Math.random() > 0.9) {
                        const baseIntensity = light.isSpotLight ? 20 : 2.5;
                        if (light.intensity > 0) {
                            light.intensity = 0;
                        } else {
                            light.intensity = baseIntensity * (Math.random() * 0.5 + 0.5);
                        }
                    }
                });
                
                handleInteractions(camera);
                updateAnimations(delta);

                if (ghostState === 'hidden') {
                    if (controls.isLocked && time > nextGhostAppearance) {
                        setGhostState('visible');
                        setGhostTimer(Math.random() * 1.0 + 0.3);
                        camera.getWorldDirection(cameraDirection);
                        const distanceBehind = Math.random() * 15 + 20;
                        const appearPosition = camera.position.clone().sub(cameraDirection.multiplyScalar(distanceBehind));
                        appearPosition.y = camera.position.y + (Math.random() - 0.5) * 4;
                        face.position.copy(appearPosition);
                        face.lookAt(camera.position);
                        face.visible = true;
                    }
                } else if (ghostState === 'visible') {
                    setGhostTimer(ghostTimer - delta);
                    if (ghostTimer <= 0) {
                        setGhostState('hidden');
                        face.visible = false;
                        setNextGhostAppearance(time + Math.random() * 20 + 10);
                    } else {
                        face.lookAt(camera.position);
                    }
                }

                renderer.render(scene, camera);
            }
            animate();
        }

        // --- From js/main.js (Entry Point) ---
        // We wrap the main execution in window.onload to ensure all assets are loaded before starting the game loop.
        window.onload = function() {
            const { scene, camera, renderer } = setupScene();

            createLightingAndWorld(scene);
            createStars(scene);
            createMoon(scene);
            createGasStation(scene);
            createSaloon(scene);
            createCat(scene);
            createVoidPortalAndTentacles(scene);
            createTrashCans(scene);
            createVegetation(scene);
            const face = createFace(scene);

            const controls = setupControls(camera);

            // Centralized collider initialization
            colliders.forEach(c => {
                c.updateWorldMatrix(true, false);
                if (c.geometry) { // It's a Mesh
                    c.geometry.computeBoundingBox();
                } else { // It's a Group, handle children
                    c.traverse((child) => {
                        if (child.isMesh) {
                            child.geometry.computeBoundingBox();
                        }
                    });
                }
            });

            createGameLoop(scene, camera, renderer, controls, face);
        }
    </script>
</body>
</html>
